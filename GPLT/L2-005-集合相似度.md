# 解题报告-L2-005

给定两个整数集合，它们的相似度定义为：N​c​​/N​t​​×100%。其中N​c​​是两个集合都有的不相等整数的个数，N​t​​是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。

### 输入格式：

输入第一行给出一个正整数N（≤50），是集合的个数。随后N行，每行对应一个集合。每个集合首先给出一个正整数M（≤10​4​​），是集合中元素的个数；然后跟M个[0,10​9​​]区间内的整数。

之后一行给出一个正整数K（≤2000），随后K行，每行对应一对需要计算相似度的集合的编号（集合从1到N编号）。数字间以空格分隔。

### 输出格式：

对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。

### 输入样例：

```
3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3

```

### 输出样例：

```
50.00%
33.33%
```

### 解题思路

* 首先想到，涉及两个集合之间的比较，如果每次都盲目比较是一个$O(M_1M_2)$的复杂度，所以通过预先排序降低复杂度
* 变长，存储结构使用vector合适
* 根据题目要求的指标，vector需要去重
* 注意输入输出格式

### 代码
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <stack>
#include <queue>
#include <vector>
#include <cmath>
#include <cstdio>
#include <bitset>
using namespace std;

static vector<int>* set;

double similarity(int i, int j){
    int pi = 0, pj = 0, result = 0;
    bool flag;
    while(pi < set[i].size() && pj < set[j].size()){
        if(set[i][pi] < set[j][pj]) flag = 1;
        else if(set[i][pi] > set[j][pj]) flag = 0;
        else{
            result++;
            flag = 1;
        }
        if(flag && pi < set[i].size()) pi++;
        else pj++;
    }
    return (double)result / (double)(set[i].size()+set[j].size()-result);
}

int main(){
    int n, size, elem;
    cin >> n;
    set = new vector<int>[n];
    // input
    for(int i=0; i<n; i++){
        cin >> size;
        for(int j=0; j<size; j++){
            scanf("%d", &elem);
            set[i].push_back(elem);
        }
        sort(set[i].begin(), set[i].end());
        set[i].erase(unique(set[i].begin(),set[i].end()), set[i].end()); // remove_duplicate
    }
    // test
    /*
    for(int i=0; i<n; i++){
        cout << set[i].size() << endl;
        for(int j=0; j<set[i].size(); j++){
            printf("%d ", set[i][j]);
        }
        cout << endl;
    }
    */
    // sim
    int k, c1, c2;
    cin >> k;
    for(int i=0; i<k; i++){
        cin >> c1 >> c2;
        printf("%0.2f%%\n", similarity(c1-1, c2-1) * 100);
    }
    return 0;
}
```
